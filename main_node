#include "ros/ros.h"
#include "ros/duration"

#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <message_filters/synchronizer.h>
#include <message_filters/connection.h>
#include <boost/bind.hpp>

#include <dynamic_reconfigure/server.h>
#include <odometry/parametersConfig.h>
 
 // Output-related libraries
#include <tf/transform_broadcaster.h>
#include <nav_msgs/Odometry.h>

#include "odometry/floatStamped.h"
#include "odometry/CustomOdometry.h"

//Values given by the text
#define BASELINE 0.583
#define RADIUS 0.1575

//Default values given by the text
#define INIT_POSITION_X 0.0
#define INIT_POSITION_Y 0.0
#define INIT_POSITION_THETA 0.0
#define INIT_VELOCITY_X 0.0
#define INIT_VELOCITY_Y 0.0
#define INIT_ANGULAR_VELOCITY 0.0
#define INIT_VELOCITY_LEFT 0.0
#define INIT_VELOCITY_RIGHT 0.0

//Approximation choice
#define EULER_APPROXIMATION true
#define RUNGE_KUTTA_APPROXIMATION false

//Topic/Frame Description
#define FRAME_ID "world"


//Struct for odometry pose
#typedef struct odometry_values{
    double x;
    double y;
    double theta;

    double v_x;
    double v_y;
    double omega;
    double steer;
    double v_r;
    double v_l;
} OdometryValues;

#typedef struct skid_steering_variables{
    double omega_r;
    double omega_l;
} SkidSteeringVariables;

odometry::parametersConfig last_config;
OdometryValues odometry_values;
double last_msg_time;

//Service for reset the odometry to initial pose
void reset_odometry_to_init(){
    odometry_values.x = INIT_POSITION_X;
    odometry_values.y = INIT_POSITION_Y;
    odometry_values.theta = INIT_POSITION_THETA;
}

//Service for reset the odometry to pose(x,y,theta)
void reset_odometry_to_pose(){}

void Euler_Approximation(double sample_time, double speed_r, double speed_l, double steer, OdometryValues& approximate_values){

    double linear_velocity = (odometry_values.v_r + odometry_values.v_l) / 2;
    double angular_velocity = odometry_values.omega;
    double delta_theta = angular_velocity * sample_time;
    
    new_odometry_data.theta = last_odometry_data.theta + delta_theta;

    approximate_values.x = odometry_values.x + linear_velocity * sample_time * cos(odometry_values.theta);
    approximate_values.y = odometry_values.y + linear_velocity * sample_time * sen(odometry_values.theta);

    approximate_values.omega = (speed_r - speed_l)/ BASELINE;

    approximate_values.v_x = ((speed_r - speed_l)/2) * cos(approximate_values.theta);
    approximate_values.v_y = ((speed_r - speed_l)/2) * sen(approximate_values.theta);

    approximate_values.steer = steer;
    approximate_values.v_r = speed_r;
    approximate_values.v_l = speed_l;

}

void Runge_Kutta_Approximation(double sample_time, double speed_r, double speed_l, double steer, OdometryValues& approximate_values){

    double linear_velocity = (odometry_values.v_r + odometry_values.v_l) / 2;
    double angular_velocity = odometry_values.omega;
    double delta_theta = angular_velocity * sample_time;
    
    new_odometry_data.theta = last_odometry_data.theta + delta_theta;

    approximate_values.x = odometry_values.x + linear_velocity * sample_time * cos(odometry_values.theta + (angular_velocity * sample_time)/2);
    approximate_values.y = odometry_values.y + linear_velocity * sample_time * sen(odometry_values.theta + (angular_velocity * sample_time)/2);

    approximate_values.omega = (speed_r - speed_l)/ BASELINE;

    approximate_values.v_x = ((speed_r - speed_l)/2) * cos(approximate_values.theta);
    approximate_values.v_y = ((speed_r - speed_l)/2) * sen(approximate_values.theta);

    approximate_values.steer = steer;
    approximate_values.v_r = speed_r;
    approximate_values.v_l = speed_l;

}

navmsg::Odometry setOdometry(){

    nav_msg::Odometry odometry;
    odometry.header.stamp = ros::Time::now();
    odometry.header.frame_id = FRAME_ID;

    odometry.pose.pose.position.x = odometry_values.x;
    odometry.pose.pose.position.y = odometry_values.y;
    odometry.pose.pose.position.z = 0.0;
    odometry.pose.pose.orientation = tf::createQuaternionMsgFromYaw(odometry_values.theta);

    odometry.twist.twist.velocity.left = odometry_values.v_l;
    odometry.twist.twist.velocity.right = odometry_values.v_r;

    return odometry;
}

geometry_msgs::TransformStamped odometryTransformation(){

    geometry_msgs::TransformStamped transformation;
    transformation.header.stamp = ros::Time::now();
    transformation.header.frame_id = FRAME_ID;
    //CHILD=???

    //transformation.transform.translation.x = odometry_values.x;
    //transformation.transform.translation.y = odometry_values.y;
    //transformation.transform.translation.z = 0.0;
    //odometry.pose.pose.position.orientation = tf::createQuaternionMsgFromYaw(odometry_values.theta);

    return transformation;
}

//odometry::CustomOdometry populateCustomOdometry per associare ad ogni odometry l'approssimazione scelta dall'utente


void subCallback(const odometry::floatStamped::Const& left, const odometry::floatStamped::Const& right,
const odometry::floatStamped::Const& steer, ...){
    string odometryModel;
    OdometryValues new_odometry_values;
    if(last_config.odometry_model_mode == EULER_APPROXIMATION){
        Euler_Approximation(delta_time, left->data, right->data, steer->data, new_odometry_values);
        odometryModel = "Euler Approximation";
    } else if(last_config.odometry_model_mode == RUNGE_KUTTA_APPROXIMATION){
        Runge_Kutta_Approximation(delta_time, left->data, right->data, steer->data, new_odometry_values);
        odometryModel = "Runge Kutta Approximation";
    } else {
        ROS_INFO("ERROR CONFIG!");
    }

    odometry_values = new_odometry_values;
}

int main(int argc, char *argv[]){

    ros::init(argc,argv,"main_node");
    ros::NodeHandle n;

    //initialization
    reset_odometry_to_init();

    odometry_values.v_r = INIT_VELOCITY_RIGHT;
    odometry_values.v_l = INIT_VELOCITY_LEFT;
    odometry_values.v_x = INIT_VELOCITY_X;
    odometry_values.v_y = INIT_VELOCITY_Y;
    odometry_values.omega = INIT_ANGULAR_VELOCITY;
    

}